#!/usr/bin/python3
# encoding=ISO-8859-1
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 3.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright Â© 2020 Josh Lee                                                #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 02:06 AM - 10 Dec, 2020       #
############################################################################## #
# =============================================================================
# Begin Imports
# -----------------------------------------------------------------------------
# builtin
"""
  Audio-Reviewer
  
  To see this use --help

  skip
  undo - go back
  keep
  remove
  
  take-notes


"""
try:
  import sys
except KeyboardInterrupt as e:
  print("KeyboardInterrupt: %s" % str(repr(e)))
  print("Script terminated by Control-C")
  print("bye!")
  exit(1)
# builtin
import os
import hashlib
import optparse
import traceback

import glob
from pprint import pprint, pformat

# Internal
from pytis import PyTis

#
# Third-Party

# -----------------------------------------------------------------------------
# End Imports
# =============================================================================
# =============================================================================
# Begin VARIABLE DEFINITIONS
# -----------------------------------------------------------------------------
__curdir__ = os.path.abspath(os.path.dirname(__file__))
__author__ = 'Josh Lee'
__created__ = '01:52 AM - 08 Dec, 2020'
__copyright__ = 'PyTis'
__version__ = '1.0'

__all__ = ['build']

acceptable_extensions = ['.wma', '.mp3', '.m4a']

# XXX::TODO::GET`ER DONE!
# __version__ = 0.1 --> creation
# __version__ = 0.2 --> it works
# __version__ = 0.3 --> clean it up
# __version__ = 0.4 --> document what has been cleaned up
# __version__ = 0.5 --> document everything else
# __version__ = 0.6 --> test everything we can, try to break it with bad input
# __version__ = 0.7 --> apply bug fixes
# __version__ = 0.8 --> document bug fixes, apply spell checking and cleanup to
#                        documentation.
# __version__ = 0.9 --> run importnanny, and ensure it is properly copyrighted!
# __version__ = 0.9? -> ready for release, just needs packaged up 
# this is where confusion sets in, I still need to finish / complete jhelp, and
# learn how to auto-build man-pages from the --help options
# __version__ = 1.0 --> release with setup.py / installation files.

# -----------------------------------------------------------------------------
# End VARIABLE DEFINITIONS
# =============================================================================
# =============================================================================
# Begin Class Helpers
# -----------------------------------------------------------------------------

class SoundFile(object):
  file_path = None
  _extension = None
  _md5 = None
  _file_name=None
  _name=None
  _base_name=None

  @property
  def full_path(self):
    return self.file_path
  fpath=filepath=full_path

  @property
  def dir_name(self):
    if not self._dir_name:
      self._dir_name = os.path.dirname(self.file_path)
    return self._dir_name
  dirname=dir_name

  @property
  def name(self):
    if not self._name:
      self._name = os.path.basename(self.base_name).split('.')[0]
    return self._name
  
  @property
  def file_name(self):
    '''
    # basename with lowered file extension
    '''
    if not self._file_name:
      self._file_name = "%s.%s" % (self.name, self.extension.lower())
    return self._file_name

  @property
  def base_name(self):
    if not self._base_name:
      self._base_name = os.path.basename(self.file_path)
    return self._base_name

  @property
  def md5(self):
    if not self._md5:
      x = open(self.file_path,'rb')
      self._md5 = md5_for_file(x)
      x.close()
    return self._md5

  @property
  def extension(self):
    if not self._extension and self._extension is None:
      try:
        self._extension = self.base_name.split('.')[-1]
      except IndexError:
        self._extension = ''
    return self._extension

  @property
  def ext(self):
    return ".%s" % self.extension

  def __init__(self, fpath):
    self.file_path = fpath


# -----------------------------------------------------------------------------
# End Class Helpers
# =============================================================================
# =============================================================================
# Begin HELPER Functions
# -----------------------------------------------------------------------------

def safe_fname(fpath, i=None):
  """ Find a safe new destination filename for a file about to be moved,
  ensuring that an existing file isn't moved over.
  Now, this appears to work, though I think the UPPER and LOWER may affect
  directories too, and I need to check that.
  """
  test_fpath = fpath

  if not os.path.exists(test_fpath):
    return test_fpath
  else:
    if not i:
      i = 1
    else:
      i=i+1
    fname = os.path.basename(fpath)
    bag = os.path.splitext(fname)
    testname = "%s_%s%s" % (bag[0],i,bag[1])

    newfile = os.path.abspath(os.path.join(os.path.dirname(fpath), testname))

    if not os.path.exists(newfile):
      if i is not None:
        log.warn("%s already existed in the outdir, added _%s to the end " \
          "of the filename." % (fname,i))
      return newfile
    else:
      return safe_fname(fpath,i)

def md5_for_file(f, block_size=2**20):

  md5 = hashlib.md5()
  while True:
    data = f.read(block_size)
    if not data:
      break
    md5.update(data)
  return md5.digest()

def build(scan_dir, store):

  """
  First look locally for overrides

Extentions Found: dict_keys(['*.wma', '*.WMA', '*.mp3', '*.tmk', '*.csv',
'*.DAT', '*.m4a', '*.txt'])

Extentions Found: dict_keys(['*.wma', '*.WMA', '*.mp3', '*.tmk', '*.DAT',
'*.m4a', '*.txt'])



  """
  import shutil
  global acceptable_extensions

  store = os.path.realpath(store)
  scandir = os.path.realpath(scan_dir)

  moved_filecount = 0
  sound_files=[]
  md5_sums = {}

  for fpath in glob.iglob(os.path.join(scandir,'**'), recursive=True):

    if os.path.isdir(fpath):
      # This is a folder
      pass
    if os.path.isfile(fpath):
      # This is a file
      source = SoundFile(fpath)
      
      if source.ext.lower() in acceptable_extensions:
        # This IS a SOUND File
        sound_files.append(fpath)

        if source.md5 not in md5_sums.keys():
          # IT hasn't been cached yet
          md5_sums[source.md5] = source
          target = SoundFile(os.path.abspath(os.path.join(store, \
            source.file_name) )) # basename with lowercase extension

          if os.path.exists(target.fpath):
            # The target exists by FILENAME
            if target.md5 == source.md5:
              # The target matches by MD5 Sum also
              print("Already copied/moved here, skip... (%s)" % source.fpath) 
            else:
              # The target exists by Filename, but has different contents,
              # THEREFORE we should keep this file, but with a new filename.

              result = shutil.move(source.fpath, safe_fname(target.fpath))
              if not os.path.isfile(result):
                print("MOVING FAILED.")
                print("A1: shutil.move(%s, safe_fname(%s))" % (source.fpath,
                  target.fpath))
              else:
                print("MOVED: %s" % result)
                moved_filecount+=1

          else:
            # This target does not exist by filename
            result = shutil.move(source.fpath, target.fpath)
            if not os.path.isfile(result):
              print("MOVING FAILED.")
              print("B2: shutil.move(%s, %s)" % (source.fpath, target.fpath))
            else:
              print("MOVED: %s" % result)
              moved_filecount+=1

        else:
          # This MD5 sum has already been cached (we have already came across a
          # file with the same contents).
          if source.base_name == md5_sums[source.md5].base_name:
            # The file with the same contents also has the same name, it just
            # is in a different folder, it must be a copy/paste thing.  Skip
            # it.

            #print("THIS MD5 ALREADY EXITS.")
            #print("already cached: %s" % md5_sums[source.md5].filepath)
            #print("now looking at duplicate located at: %s" % source.filepath)
            # print("")
            pass
          else:
            # The contents already exist, but with a different filename.  Since
            # we already have a duplicate, we will skip moving.
            print("X"*80)
            print("THIS MD5 ALREADY EXITS / BUT WITH A DIFFERENT FILENAME.")
            print("already cached: %s" % md5_sums[source.md5].filepath)
            print("now looking at duplicate located at: %s" % source.filepath)
            print("")
      else:
        # Not a VALID file extension
        pass

    
  print("%s files scanned" % len(sound_files))
  print("%s files moved" % moved_filecount)
  PyTis.die("exiting.")
# -----------------------------------------------------------------------------
# End HELPER Functions
# =============================================================================
# =============================================================================
# Begin MAIN PROGRAM FUNCTIONS
# -----------------------------------------------------------------------------



# -----------------------------------------------------------------------------
# End MAIN PROGRAM FUNCTIONS
# =============================================================================
# -----------------------------------------------------------------------------
# Begin MAIN 
# -----------------------------------------------------------------------------

def main():
  filename = os.path.abspath(os.path.join(PyTis.__configdir__, 
    '%s.ini' % os.path.basename(os.path.abspath(sys.argv[0])).split('.')[0]))

  cfile = PyTis.COBJ.fload(filename)
  scan_dir = cfile.scan_dir
  store = cfile.store
    

  build(scan_dir, store)
  return

# -----------------------------------------------------------------------------
# End MAIN 
# =============================================================================

if __name__ == '__main__':
  """

  Main function included to create test data for non-lambda debugging.

  """
  sys.exit(main())

  try:
    sys.exit(main())
  except Exception as e:
    print("An error has occured.\n")
    print("="*80)
    type_,value_,traceback_ = sys.exc_info()
    print("ERROR REPORT:")
    print("Line: ", traceback_.tb_lineno)
    print("Type: ", type_)
    print("Argument(s): %s" % repr(e.args))
    print("Value(s): ", value_)
    print("Traceback follows:")
    print("-"*80)
    for tb_line in traceback.format_tb(traceback_):
      print(tb_line)
    print(str(e))
    print("="*80)
    sys.exit(1)

# =============================================================================
