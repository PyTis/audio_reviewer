#!/usr/bin/python
# encoding=UTF-8
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 3.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright (c) 2020 Josh Lee                                              #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 01:58 AM - 08 Dec, 2020       #
############################################################################## #
# =============================================================================
# Begin Imports
# -----------------------------------------------------------------------------
# builtin
"""
  Audio-Reviewer
  
  To see this use --help

  skip
  undo - go back
  keep
  remove
  
  take-notes


"""
try:
  import sys
except KeyboardInterrupt as e:
  print("KeyboardInterrupt: %s" % str(repr(e)))
  print("Script terminated by Control-C")
  print("bye!")
  exit(1)
# builtin
import os
import glob
import atexit
import shutil
import optparse
import readline
import traceback
import subprocess

# Internal
from pytis import PyTis

from lib.multi_line_input import multiline_input
import lib.build as BUILD
import lib.pyrotate as pyrotate
import lib.errors as errors
import lib.stopwatch as stopwatch

sw=stopwatch.Stopwatch(True)
#
# Third-Party

die=Die=DIE=errors.Die

# -----------------------------------------------------------------------------
# End Imports
# =============================================================================
# =============================================================================
# Begin VARIABLE DEFINITIONS
# -----------------------------------------------------------------------------

__curdir__ = os.path.abspath(os.path.dirname(__file__))
__author__ = 'Josh Lee'
__created__ = '01:52 AM - 08 Dec, 2020'
__copyright__ = 'PyTis'
__version__ = '1.0'
default_speed = 1.0
__all__ = ()

python_version = float("%s.%s"%(sys.version_info.major,sys.version_info.minor))

acceptable_extensions = ['wma', 'mp3', 'm4a']
# XXX::TODO::GET`ER DONE!
# __version__ = 0.1 --> creation
# __version__ = 0.2 --> it works
# __version__ = 0.3 --> clean it up
# __version__ = 0.4 --> document what has been cleaned up
# __version__ = 0.5 --> document everything else
# __version__ = 0.6 --> test everything we can, try to break it with bad input
# __version__ = 0.7 --> apply bug fixes
# __version__ = 0.8 --> document bug fixes, apply spell checking and cleanup to
#                        documentation.
# __version__ = 0.9 --> run importnanny, and ensure it is properly copyrighted!
# __version__ = 0.9? -> ready for release, just needs packaged up 
# this is where confusion sets in, I still need to finish / complete jhelp, and
# learn how to auto-build man-pages from the --help options
# __version__ = 1.0 --> release with setup.py / installation files.

# -----------------------------------------------------------------------------
# End VARIABLE DEFINITIONS
# =============================================================================
# =============================================================================
# Begin Class Helpers
# -----------------------------------------------------------------------------


class SoundFile(object):
  file_path = None
  _extension = None
  _md5 = None
  _file_name=None
  _name=None
  _folder=None
  _dirname=None
  _base_name=None
  current_state=None
  enum = 'store' # | rem_dir | review_dir | keep

# store | keep_dir | rem_dir | review_dir

  @property
  def enumer(self):
    return os.path.basename(os.path.dirname(self.fpath))

  @property
  def full_path(self):
    return self.file_path
  fpath=filepath=full_path

  @property
  def folder(self):
    if not self._folder:
      self._folder = os.path.basename(os.path.dirname(self.file_path))
    return self._folder

  @property
  def dirname(self):
    if not self._dirname:
      self._dirname = os.path.dirname(self.file_path)
    return self._dirname

  @property
  def name(self):
    if not self._name:
      self._name = os.path.basename(self.base_name).split('.')[0]
    return self._name
  
  @property
  def file_name(self):
    '''
    # basename with lowered file extension
    '''
    if not self._file_name:
      self._file_name = "%s.%s" % (self.name, self.extension.lower())
    return self._file_name

  @property
  def base_name(self):
    if not self._base_name:
      self._base_name = os.path.basename(self.file_path)
    return self._base_name

  @property
  def md5(self):
    if not self._md5:
      x = open(self.file_path,'rb')
      self._md5 = BUILD.md5_for_file(x)
      x.close()
    return self._md5

  @property
  def extension(self):
    if not self._extension and self._extension is None:
      try:
        self._extension = self.base_name.split('.')[-1]
      except IndexError:
        self._extension = ''
    return self._extension

  @property
  def ext(self):
    return ".%s" % self.extension

  def __init__(self, fpath):
    self.reload(fpath)

  def reload(self, fpath):
    self._extension = None
    self._md5 = None
    self._file_name=None
    self._name=None
    self._dir_name=None
    self._dirname=None
    self._base_name=None
    self.current_state=None
    self.file_path = fpath

  def play(self, vlc_base, speed=default_speed):
    """

    store='/home/jlee/github/audio_reviewer/src/store'
    keep_dir = /home/jlee/github/audio_reviewer/src/store/to-keep
    rem_dir = /home/jlee/github/audio_reviewer/src/store/to-remove
    review_dir = /home/jlee/github/audio_reviewer/src/store/to-review
    vlc_base=file:///C:/cygwin64/home/jlee/github/audio_reviewer/src/

    """
    global default_speed
    vlc=os.path.abspath("/cygdrive/c/Program Files (x86)/VideoLAN/VLC/vlc.exe")
    vpath = os.path.join(vlc_base, self.file_path[1:])
    
#    PyTis.clearScreen()
#    print('vpath=', vpath)
#    PyTis.toContinue()
    try:
      float(speed)
    except:
      speed = default_speed
    else:
      if not speed:
        speed = default_speed

    if not speed:
      speed=1.0


    fire_command = "'%s' --rate=%s --playlist-enqueue '%s'" % (vlc,speed,vpath)
    self.current_state = 'playing'
    return subprocess.Popen(fire_command, shell=True, stdout=subprocess.PIPE)

class Worker(object):

  sound_files = []
  _current_file = None
  _scan_dir = None
  _current_pointer = None
  _speed = 1.0


  def set_speed(self, sp):
    self._speed=sp
  def get_speed(self):
    return self._speed
  playback_speed=speed=property(get_speed, set_speed)

  def set_scan_dir(self, sd):
    self._scan_dir=sd
  def get_scan_dir(self):
    return self._scan_dir
  scan_dir=property(get_scan_dir, set_scan_dir)

  def set_current_pointer(self, p):
    if not self.file_count:
      raise errors.InvalidInput("Cannot set a pointer, no files are loaded")
    if p >= self.file_count: p=0
    self._current_pointer=p
  def get_current_pointer(self):
    return self._current_pointer
  current_pointer=property(get_current_pointer, set_current_pointer)

  def first(self):
    self.current_pointer = 0

  def next(self):
    self.current_pointer += 1

  def previous(self):
    self.current_pointer -= 1

  def set_current_file(self, sf):
    self._current_file=sf

  def get_current_file(self):
    return self._current_file
  current_file=property(get_current_file, set_current_file)

  @property
  def file_count(self):
    return len(self.sound_files)

  def header(self, editing=False):
    sys.stdout.write("RECORDS: %s" % self.file_count)

    if self.current_file:
      sys.stdout.write("\t\t FOLDER: %s \t\t FILE: %s" % (
        os.path.basename(self.scan_dir), self.current_file.name) )

      sys.stdout.write("\nFILENAME: %s" % self.current_file.base_name)
      sys.stdout.write("\t\tFILE %s of %s" % (self.current_pointer+1,
        self.file_count))

      record = self.db.get(self.current_file.fpath, { })
      summary = record.get('summary', '').strip()
      if not editing and summary:
        sys.stdout.write("\nSUMMARY: %s" % summary)

    else:
      sys.stdout.write("\t\t FOLDER: %s" % os.path.basename(self.scan_dir))


    sys.stdout.write("\n%s\n" % ('='*80))

    #sys.stdout.write("\n"); sys.stdout.flush()

     # print("FILE: %s" % self.current_file.name)

  def __init__(self, db, speed, store_dir, keep_dir, rem_dir, review_dir, vlc_base):
    self.db = db

    self.store_dir = store_dir
    self.keep_dir = keep_dir
    self.rem_dir = rem_dir
    self.review_dir = review_dir
    self.playback_speed = speed

    self.vlc_base =  vlc_base
    atexit.register(self.closePlayer)

  def scan(self, scan_dir):
    """
    We are going to scan, and load files into the "sound_files" attribute.
    We need to first clear this, in case it was ran before.
    """
    global acceptable_extensions

    self.scan_dir = scan_dir

    self.sound_files = []

    for f in glob.iglob(os.path.join(self.scan_dir,'**'), recursive=True):
      if os.path.isfile(f):
        source = SoundFile(f)
        if os.path.basename(f.lower()).split('.')[-1] in acceptable_extensions:
          self.sound_files.append(source)



  def start(self, pre_text=None):
    PyTis.clearScreen()
    self.header() 
    answers = ['', 'l', 'h', 'q']
    question = '(L)isten, (H)elp, (Q)uit '

    example_or_hint=''
    helptext="""
  L   - Use "L" to play the first file.
  H/? - Type "H" or "?" for help.
"""
    answers.sort()
    r=getResult(answers, question, helptext, example_or_hint, default='L',
      required=False, pre_text=None)

    if r == 'l':
      # Listen called, set pointer
      if len(self.sound_files):
        self.current_pointer = 0
      else:
        print("After scanning the direcotry, there are no sound files loaded.")
        print("We cannot play a song, no songs to play.")

    ### # can be expanded HERE later to handle other answers 

    return


  def closePlayer(self):
    self.current_state=None
    try:
      self.vlc_process.kill()
      self.vlc_process.terminate()
    except AttributeError:
      return 1
    except (PermissionError, OSError):
      return 0 #  (already done)
    else:
      return 0

  def playFile(self):
    # set current file with pointer
    self.current_file = self.sound_files[self.current_pointer]
    # set is playing
    self.vlc_process = self.current_file.play(self.vlc_base, self.speed)

  def getSummary(self, default=''):
    sys.stdout.write('Hold "CONTROL" and press "C" to cancel. <CTRL+C>'+"\n")
    sys.stdout.write('-'*80+"\n")
    sys.stdout.write('SUMMARY: ')
    try:
      readline.set_startup_hook(lambda: readline.insert_text(default))
      summary = get_input()
    finally:
      readline.set_startup_hook(None)
    
    if not summary.strip():
      print("Nothing entered, please provide a summary")
      return self.getSummary(default)
    else:
      return summary
    
  def getDescription(self, default=''):
    if not default:
      default = "0:00 - "
    data = multiline_input(prompt='DESCRIPTION: ', default=default)
    if not data:
      print("Nothing entered, please provide a description.")
      return self.getDescription(default)
    else:
      return data

  def moveFile(self, new_dir):
    try: self.closePlayer()
    except: pass

    try:
      old = self.current_file.fpath
      new = os.path.join(new_dir, self.current_file.file_name)
      new = os.path.abspath(new)

      if os.path.exists(new):
        new = safe_fname(new)

      if os.path.exists(new):
        raise Exception("Cannot find a safe name for %s to place in %s" % \
          (self.current_file.file_name, new_dir) )

      shutil.move(old, new)

    except IOError:
      raise
    except OSError:
      raise
    except PermissionError:
      raise
    else:
      return new

  def work(self, trigger=False, trigger2=False):
    # stop current playing, CLOSE VLC
    if self.current_file and self.current_file.current_state == 'playing':
      self.closePlayer()

    PyTis.clearScreen()
    # to play from answers
    if self.current_pointer is not None:
      self.playFile()

    self.header() 

    # ask what to do now
    ranswers = []
    rquestions = []

    ## XXX-FINDME

    # Trigger IF
    if trigger or self.current_file.folder != 'to-keep':

      if self.current_pointer is not None and self.current_pointer > 0:
        ranswers.append('p') # handled
        rquestions.append('(P)revious')

      if self.current_file.folder in ('to-remove', 'to-review'):
        ranswers.append('u') # handled
        rquestions.append('(U)ndo')
      else:
        ranswers.append('d') # handled
        rquestions.append('(D)elete')

      if self.current_file.folder != 'to-keep':
        ranswers.append('k')
        rquestions.append('(K)eep')
      else:
        if trigger:
          ranswers.append('e')
          rquestions.append('(E)dit')

      if self.current_file.folder != 'to-review':
        ranswers.append('r')
        rquestions.append('(R)eview later')

      if self.current_pointer is not None and self.current_pointer < self.file_count -1:
        ranswers.append('s') # handled
        rquestions.append('(S)kip')

        ranswers.append('n') # handled
        rquestions.append('(N)ext')

      rquestion = ', '.join(rquestions)

      example_or_hint=''
      helptext="""
    K - Use "K" to Keep the current file.
    H/? - Type "H" or "?" for help.
  """
      
      try:
        ranswers.sort()
        r=getResult(ranswers, rquestion, helptext, example_or_hint, None, True, \
          None)
      except errors.QuitNow:
        self.closePlayer()
        print("Quit called,\nbye!")
        return 0
      except Exception:
        self.closePlayer()
        raise
    # Trigger else
    else:
      r='k'
    # FI Trigger

    # XXX-TODO: PREVIEW 

    # handle keep
    if r in ('e', 'k'):

      record = self.db.get(self.current_file.fpath, { })
      record['name'] = self.current_file.name
      record['filename'] = self.current_file.file_name
      record['filepath'] = self.current_file.fpath

      summary = record.get('summary', '')
      description = record.get('description', "")

      if summary.strip() or description.strip() or trigger2:
        PyTis.clearScreen()
        self.header(True)


        print("PREVIEW EXISTING VALUES")
        print("SUMMARY: %s\n" % summary)

        print("DESCRIPTION -\n%s" % "\n".join(["\t%s" % d for d in \
          PyTis.wrap(description, 70).split("\n") ]))
        print('-'*80)

        banswers=['s','d','l','']
        helptext='Edit (S)ummary, (D)escription or go (L)eave Edit Mode.'
        bquestion='(S)ummary || (D)escription || (L)eave '

        if self.current_pointer > 0:
          banswers.append('p')
          helptext='%s listen to the (P)revious file' % helptext
          bquestion='%s || (P)revious ' % bquestion

        if self.current_pointer < self.file_count -1:
          banswers.append('n')
          helptext='%s or move on to the (N)ext file' % helptext
          bquestion='%s || (N)ext ' % bquestion


        example_or_hint=''
        helptext="""
%s.

    H/? - Type "H" or "?" for help.
""" % helptext
      
        ## XXX-FINDME
        # EDIT MODE by request
        banswers.sort
        b=getResult(banswers, bquestion, helptext, '', default=None,
          required=True, pre_text=None)

        if b =='q':
          raise errors.QuitNow('Bye!')

        elif b =='s':
          try:
            summary = self.getSummary(summary)
          except KeyboardInterrupt:
            return self.work(False, True)
          else:
            record['summary'] = summary
            self.db.update({self.current_file.fpath : record})
            self.db.save()

            return self.work()


        elif b == 'd':
          description = self.getDescription(description)

          record['description'] = description
          self.db.update({self.current_file.fpath : record})
          self.db.save()

          return self.work()

        elif b == 'p':
          self.previous()
          return self.work()

        elif b == 'n':
          self.next()
          return self.work()


        elif b == 'l':
          print("Go BACK")
          return self.work(True)


      else:
        # keep review dropped automatically in here if no summary or
        # description existed, or user entered keep from store
        print("FILENAME: %s" % self.current_file.base_name)
        print("NO EXISTING VALUES (first time asked)")
        print('-'*80)


        try:
          summary = self.getSummary(summary)
        except KeyboardInterrupt:
          return self.work(False, True)
        else:
          record['summary'] = summary
          self.db.update({self.current_file.fpath : record})
          self.db.save()
          print('saving to file...')

        try:
          description = self.getDescription(description)
        except KeyboardInterrupt:
          return self.work(False, True) # go up one level
        else:
          record['description'] = description
          self.db.update({self.current_file.fpath : record})
          self.db.save()
          print('saving to file...')

        PyTis.toContinue()

      # XXX-TODO: VERIFY

      # review changes
      if os.path.abspath(self.current_file.dirname) != \
        os.path.abspath(self.keep_dir):
        self.current_file.reload( self.moveFile(self.keep_dir) )
    
      self.next()        
      

    # handle anything else.

    # HANDLE UNDO DELETE
    if r=='u': # undo a delete
      
      self.current_file.reload( self.moveFile(self.store_dir) )
#        self.next()


    # HANDLE REVIEW LATER
    if r=='r': # review later

    ## XXX-FINDME
      self.current_file.reload( self.moveFile(self.review_dir) )
      self.next()

    # HANDLE DELETE (move to directory to be deleted later)
    if r=='d': # delete

      if self.current_file.folder == 'to-keep':

        # keep notes we took, but flag it as Deleted
        old_path = self.current_file.fpath
        record = self.db.get(old_path, { })
        newpath = self.moveFile(self.rem_dir) 
        record['filepath'] = newpath 
        record['DELETE'] = True
        self.db.update({newpath : record})
        del self.db[old_path]
        self.db.save()

      else:
        newpath = self.moveFile(self.rem_dir) 

      self.current_file.reload(newpath)
      self.next()

    # HANDLE PREVIOUS
    if r=='p':
      self.previous()

    # HANDLE NEXT (or skip (same thing))
    if r=='n' or r=='s':
      self.next()

    return self.work()

# -----------------------------------------------------------------------------
# End Class Helpers
# =============================================================================
# =============================================================================
# Begin HELPER Functions
# -----------------------------------------------------------------------------

def safe_fname(fpath, i=None):
  """ Find a safe new destination filename for a file about to be moved,
  ensuring that an existing file isn't moved over.
  Now, this appears to work, though I think the UPPER and LOWER may affect
  directories too, and I need to check that.
  """
  test_fpath = fpath

  if not os.path.exists(test_fpath):
    return test_fpath
  else:
    if not i:
      i = 1
    else:
      i=i+1
    fname = os.path.basename(fpath)
    bag = os.path.splitext(fname)
    testname = "%s_%s%s" % (bag[0],i,bag[1])

    newfile = os.path.abspath(os.path.join(os.path.dirname(fpath), testname))

    if not os.path.exists(newfile):
      if i is not None:
        log.warn("%s already existed in the outdir, added _%s to the end " \
          "of the filename." % (fname,i))
      return newfile
    else:
      return safe_fname(fpath,i)

def getResult(answers=[], question='', helptext='', example_or_hint=None, \
  default=None, required=False, pre_text=None):

  if pre_text:
    print(pre_text)

  result = getInput(question, answers, helptext, example_or_hint, default,
    required).lower()

  if not result and '' in answers:
    if default:
      return default
    else:
      return ''

  if result not in answers:
    PyTis.clearScreen()

    err_msg = "Not a valid answer.  Please enter a valid response."
    if pre_text:
      err_msg = "%s\nYou can type ? or h to display help text." % err_msg
    return getResult(answers, question, helptext, example_or_hint, default,
      required, err_msg)
  else:
    return result

def getInput(question, answers, helptext='No help for this command', \
  example_or_hint=None, default=None, required=False):
  """
  Full Name - press Enter for default: root
  if helptext:
    if required:
      Full Name [i.e. John Smith (required)]:
    else:
      Full Name [i.e. John Smith (or leave blank)]:
  else:
    if required:
      Full Name (required):
    else:
      Full Name:
  """

  if example_or_hint:
    if required:
      txt = '%s %s ' % (question,example_or_hint)
    else:
      if default:
        txt = '%s %s (%s or leave blank) ' % (question, example_or_hint,
          default)
      else:
        txt = '%s %s (or leave blank) ' % (question, example_or_hint)
  else:
    #if default and required and not example_or_hint:
    if default and not example_or_hint:
      example_or_hint='(default "%s")' % default
    txt = '%s %s ' % (question, example_or_hint)

  try:
    res = get_input("%s>>> " % (txt))
  except (KeyboardInterrupt,EOFError):
    print("\nInvalid input, press 'q' to quit or 'h' for help.")
    return getInput(question, answers, helptext, example_or_hint, default,
      required)


  if not res.strip() and required:
    if default:
      PyTis.__option_always__ = [False]

      if PyTis.getInputYN('Use default: %s?' % (default),
          'This will set the %s to the system default of "%s"' % (question,
            default), PyTis.__input_options__,[]):
        return default
      else:
        if not example_or_hint: 
          example_or_hint='(default "%s")' % default
        return getInput(question, answers, helptext, example_or_hint, default,
          required)

    else:
      print("\n")
      print('Nothing entered "%s" is required, please try again.' % question)
      print("\n")
      if not example_or_hint:
        example_or_hint='(default "%s")' % default
      return getInput(question, answers, helptext, example_or_hint, default,
        required)


  elif not res.strip() and not required and default:
    return default

  if res.strip().lower() in ['h','?']:
    print("Possible Answers: %s" % ','.join(['"%s"' % s for s in answers]))
    print("\nHELP (q to quit)" )
    print("\n\t? or "+'"h"'+" for this help")

    if helptext:
      if required:
        r=''
      else:
        r=''
      print("\n%s" % PyTis.fixWidth("%s%s"%(r,helptext)))
    else:
      print("\n%s" % PyTis.fixWidth(helptext))

    return getInput(question, answers, helptext, example_or_hint, default,
      required)

  if res.strip().lower() == 'q':
    raise errors.QuitNow(question)
  else:
    return res


def build(scan_dir, store):
  return BUILD.build(scan_dir, store)

def backup_ini(opts, store_file):
  global log

  try:
    old = os.path.abspath(store_file)
    new = "temp-%s.bak" % os.path.basename(store_file)

    new = os.path.abspath(new)

    if os.path.exists(new):
      new = safe_fname(new)

    if os.path.exists(new):
      raise Exception("Cannot backup INI file." )

    shutil.copy(old, new)

  except IOError:
    raise
  except OSError:
    raise
  except PermissionError:
    raise
  else:
    pass

  
  pyrotate.run(opts, [store_file], log)
  os.unlink(old)
  shutil.move(new, old)


# FINDME
def run(toscan, store, keep_dir, rem_dir, review_dir, store_file, vlc_base,
  speed=default_speed):
  """
  First look locally for overrides

  """
  global log

  print('store_file: ', store_file)
  PyTis.COBJ.ConfigObj.save=PyTis.COBJ.ConfigObj.write
  db = PyTis.COBJ.fload(store_file)
  worker = Worker(db, speed, store,  keep_dir, rem_dir, review_dir, vlc_base)

  worker.scan(toscan) # loads files


  try:
    worker.start() # first run, sets pointer
    worker.work()
  except errors.QuitNow:
    worker.closePlayer
  finally:
    print("bye!!")

  return

def get_input(*args, **kwargs):
  global python_version
  if python_version >= 3.0:
    return input(*args,**kwargs)
  else:
    return raw_input(*args,**kwargs)

# -----------------------------------------------------------------------------
# End HELPER Functions
# =============================================================================
# =============================================================================
# Begin MAIN PROGRAM FUNCTIONS
# -----------------------------------------------------------------------------



# -----------------------------------------------------------------------------
# End MAIN PROGRAM FUNCTIONS
# =============================================================================
# -----------------------------------------------------------------------------
# Begin MAIN 
# -----------------------------------------------------------------------------

def main():
  """usage: reviewer [optional[file or pattern]]
================================================================================
Tool so I don't have to remember the commands for find replace with perl.
Yes, all of this can be done by piping commands together and that is why I am
printing those commands to the screen, so I can see them and memorize them.

Also has some nice options and can additinally do file names or portions 
of file names.
  """
  global log, __author__, __copyright__, __created__, __version__
  global default_speed
  valid_actions = ['build','run', 'scan', 'rescan', 'review']

  help_dict = dict(version=__version__,
             author=__author__,
             created=__created__,
             copyright=__copyright__)
  parser = PyTis.MyParser()
  parser.extra_txt = """
CHANGE LOG:
  
  v1.0 
    FIRST ADDITION OF THIS CHANGE LOG

EXAMPLES:  

""" % help_dict

  #parser.set_description(__doc__)

  parser.set_usage(main.__doc__)
  parser.formatter.format_description = lambda s:s
  parser.add_option("-D", "--debug", action="store_true",
           default=False, 
           help="Enable debugging")

  parser.add_option("-b", "--backup", action="store_true",
           default=False,
           help="Creates backups with .bak as the extension")


  parser.add_option("-n", "--name", action="store_true",
           default=False,
           help="Default behavior: replace in files, using this turns that feature off "
             "and tells this tool to actuall replace parts of file names.")
             
  parser.add_option("-f", "--force", action="store_true",
           default=False,
           help="Dissable prompts. Commonly used when called by other programs, this will force "
             "the program to run without asking for user input, attempting to run with "
             "whatever input is given. Only errors are output.")

  parser.add_option("-v", "--version", action="store_true",
           default=False, 
           help="Display Version")
  
  parser.add_option("-V", "--verbose", action="store_true",
           default=False, 
           help="Be more Verbose")

  
  # -------------------------------------------------------------------------
  # RUNTIME setting
  runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS")

  runtime.add_option("-s", "--speed", action="store", default=default_speed, 
           dest='speed', help="Default playback speed.")

  extended_action_help = """

build -> runs a scan on the calls dir, and copies files into the store, that
don't already exist there.

run -> Reviews "keep dir"

scan/rescan -> Reviews "store dir"

review -> Reviews "review dir"

"""
  runtime.add_option("-a", "--action", type="choice", action="store",
                    default=None, 
                    dest='action_selected',
                    choices=valid_actions,
                    help="What to do with a saved section. Default 'run', "
                         "choices: <%s>`$`%s" % (', '.join(valid_actions),
                         extended_action_help))

  parser.add_option_group(runtime)
  # -------------------------------------------------------------------------
  # BUILD setting
  build_grp = optparse.OptionGroup(parser, "-- BUILD SCAN DIRECTORY SETTINGS")

  build_grp.add_option("-C", "--_case", action="store_true",
           default=False,
           help="Searches case-insensative")

  build_grp.add_option("-I", "--_iterate", action="store_true",
           default=False,
           help="Default behavior: recursive, specify this to not traverse into sub-directories")


  parser.add_option_group(build_grp)
  # -------------------------------------------------------------------------
  # SCAN setting
  scn = optparse.OptionGroup(parser, "-- FILE SCAN SETTINGS")

  scn.add_option("-c", "--case", action="store_true",
           default=False,
           help="Searches case-insensative")

  scn.add_option("-i", "--iterate", action="store_true",
           default=False,
           help="Default behavior: recursive, specify this to not traverse into sub-directories")


  parser.add_option_group(scn)



  # -------------------------------------------------------------------------
  # variable setting
  confvars = optparse.OptionGroup(parser, "-- CONFIGURATION SETTINGS")

  parser.add_option_group(confvars)



  (opts, args) = parser.parse_args()

  log = PyTis.set_logging(opts, 'reviewer')

  filename = os.path.abspath(os.path.join(PyTis.__configdir__, 
    '%s.ini' % os.path.basename(os.path.abspath(sys.argv[0])).split('.')[0]))


  if opts.debug:
    main.__doc__ = "%s\n\n  CONFIG FILE: %s" % (main.__doc__,
      os.path.abspath(filename))

  cfile = PyTis.COBJ.fload(filename)

  store = cfile.store
  keep_dir = cfile.keep_dir
  rem_dir = cfile.rem_dir
  review_dir = cfile.review_dir
  store_file = cfile.store_file
  scan_dir = cfile.scan_dir
  vlc_base = cfile.vlc_base

  if not opts.action_selected and len(args) < 1:
    parser.print_help()
  elif not opts.action_selected and len(args) > 1:
    print("ERROR: too many action items provided on STDIN") 
    return 1
  elif not opts.action_selected and len(args) == 1:
    arg = args[0].lower()
    if arg not in valid_actions:
      print("ERROR: Action '%s' provided via STDIN not in valid actions: " \
        "<%s>" % (arg, ', '.join(valid_actions) ) )
      return 1
    else:
      opts.action_selected = arg

  if not opts.action_selected:
    parser.print_help()
    return
  else:
    opts.action_selected = opts.action_selected.lower()

  backup_ini(opts, store_file)

  try:
    if opts.action_selected == 'build':
      return build(scan_dir, store)

    if opts.action_selected in ('run'):
      return run(keep_dir, store, keep_dir, rem_dir, review_dir, store_file,
        vlc_base, opts.speed)

    if opts.action_selected in ('review'):
      return run(review_dir, store, keep_dir, rem_dir, review_dir, store_file,
        vlc_base, opts.speed)

    if opts.action_selected in ('scan','rescan'):
      return run(store, store, keep_dir, rem_dir, review_dir, store_file,
        vlc_base, opts.speed)

    log.debug("OPTS: %s", opts)
    log.debug("ARGS: %s", args)
    return 1

  except KeyboardInterrupt:
    print('bye!')
    sys.exit(1)
  else:
    sys.exit(0)

# -----------------------------------------------------------------------------
# End MAIN 
# =============================================================================

if __name__ == '__main__':
  """

  Main function included to create test data for non-lambda debugging.

  """
  try:
    sys.exit(main())
  except Exception as e:
    print("An error has occured.\n")
    print("="*80)
    type_,value_,traceback_ = sys.exc_info()
    print("ERROR REPORT:")
    print("Line: ", traceback_.tb_lineno)
    print("Type: ", type_)
    print("Argument(s): %s" % repr(e.args))
    print("Value(s): ", value_)
    print("Traceback follows:")
    print("-"*80)
    for tb_line in traceback.format_tb(traceback_):
      print(tb_line)
    print(str(e))
    print("="*80)
    sys.exit(1)

# =============================================================================
